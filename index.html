<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Analizador de funciones racionales</title>

<script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<style>
  :root{
    --bg:#f4f6fb; --card:#fff; --accent:#2563eb; --muted:#6b7280; --danger:#ef4444;
  }
  body{ margin:0; font-family:Inter, Roboto, Arial, sans-serif; background:var(--bg); color:#111827; padding:20px; }
  .wrap{ max-width:1100px; margin:0 auto; }
  .card{ background:var(--card); border-radius:10px; padding:16px; box-shadow:0 6px 18px rgba(16,24,40,0.06); }
  h1{ margin:0 0 8px 0; font-size:20px; }
  .example{ background:#eef2ff; border-left:4px solid var(--accent); padding:10px; border-radius:6px; margin-bottom:12px; color:#0f172a; }
  .row{ display:flex; gap:12px; align-items:center; }
  input[type="text"]{ flex:1; padding:10px 12px; border-radius:8px; border:1px solid #e6edf8; font-size:15px; }
  button{ background:var(--accent); color:#fff; border:0; padding:10px 14px; border-radius:8px; cursor:pointer; font-weight:600; }
  .main-grid{ display:grid; grid-template-columns: 1fr 460px; gap:14px; margin-top:14px; align-items:start; }
  .small{ font-size:13px; color:var(--muted); }
  table{ width:100%; border-collapse:collapse; margin-top:8px; }
  th,td{ padding:6px 8px; border-bottom:1px dashed #eee; text-align:center; font-size:14px; }
  .danger{ color:var(--danger); }
  canvas{ width:100% !important; height:420px !important; background:#fff; border-radius:8px; padding:6px; }
  .guide{ margin-top:12px; background:#f9fafb; padding:12px; border-radius:8px; border:1px solid #eee; color:var(--muted); }
  .meta { margin-top:8px; font-size:14px; }
  .math { font-family: "Times New Roman", Times, serif; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Analizador de funciones racionales</h1>
      <div class="example"><strong>Ejemplo:</strong> <span class="small">f(x) = (x^2 - 4) / (x - 2)</span></div>

      <div class="row">
        <input id="fnInput" type="text" placeholder="(numerador)/(denominador) — Ej: (2*x^2 - 5*x + 3)/(x - 1)" />
        <button id="btnAnalyze">Analizar</button>
      </div>

      <div class="guide">
        <strong>Cómo ingresar:</strong>
        <ul>
          <li>Usa <code>x</code> como variable.</li>
          <li>Potencias: <code>x^2</code>, multiplicación explícita: <code>2*x</code>.</li>
          <li>Formato recomendado: <code>(numerador)/(denominador)</code>. Si no es fracción, escribe el polinomio.</li>
        </ul>
      </div>
    </div>

    <div class="main-grid">
      <div class="card">
        <div id="resultsArea">
          <div id="intro" class="small meta">Introduce una función y pulsa <strong>Analizar</strong>.</div>

          <div id="details" style="display:none; margin-top:10px;">
            <p><strong>Simplificación:</strong> <span id="simplified"></span></p>
            <p><strong>Dominio (texto):</strong> <span id="domainText"></span></p>
            <p><strong>Dominio (notación):</strong> <span id="domainMath" class="math"></span></p>
            <p><strong>Asíntotas verticales:</strong> <span id="vertAsym"></span></p>
            <p><strong>Asíntota horiz./oblicua:</strong> <span id="horizAsym"></span></p>
            <p><strong>Huecos:</strong> <span id="holes"></span></p>
            <div id="rangeWrap" style="display:none;">
              <p><strong>Rango (notación):</strong> <span id="rangeMath" class="math"></span></p>
              <p><strong>Rango (texto):</strong> <span id="rangeText"></span></p>
            </div>

            <div style="margin-top:8px;">
              <strong>Tabla</strong>
              <div id="tableWrap" class="small"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <canvas id="chartCanvas"></canvas>
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = id => document.getElementById(id);
  const math = window.math;

  function r2(n){ if(typeof n!=='number' || !isFinite(n)) return n; return Math.round(n*100)/100; }
  function fmt(n){ if(n===null||n===undefined) return '—'; if(!isFinite(n)) return '—'; if(Math.abs(n-Math.round(n))<1e-8) return String(Math.round(n)); return r2(n).toString(); }

  // split (numerator)/(denominator) at top level
  function splitFrac(s){
    let str = s.trim().replace(/^\s*f\s*\(\s*x\s*\)\s*=\s*/i,'');
    let depth=0;
    for(let i=0;i<str.length;i++){
      const ch=str[i];
      if(ch==='(') depth++;
      if(ch===')') depth--;
      if(ch==='/' && depth===0){
        return [str.slice(0,i).trim(), str.slice(i+1).trim()];
      }
    }
    return [str.trim(), '1'];
  }

  // Evaluate expression safely with mathjs
  function compileExpr(exprStr){
    try{
      const node = math.parse(exprStr.replace(/\^/g,'**'));
      return node.compile();
    }catch(e){
      return null;
    }
  }

  // detect singular x's (where denom ~ 0) by scanning and refining
  function findSingulars(denEval, xMin=-100, xMax=100, step=0.1){
    const suspects = new Set();
    for(let x=xMin; x<=xMax; x+=step){
      const v = denEval(x);
      if(!isFinite(v) || Math.abs(v) < 1e-6) suspects.add(Math.round(x*100)/100);
    }
    return Array.from(suspects).sort((a,b)=>a-b);
  }

  // adaptive sampling: subdivide interval if linear interpolation error large or steep slope
  function adaptiveSample(fEval, a, b, fa, fb, tol=0.5, depth=0, maxDepth=12){
    const mid = (a+b)/2;
    const fm = fEval(mid);
    if(!isFinite(fa) || !isFinite(fb) || !isFinite(fm)) {
      // if any is infinite or NaN, we stop subdividing: return null to create gaps
      return [ {x:a,y:fa}, {x:mid,y:NaN}, {x:b,y:fb} ];
    }
    const lin = (fa+fb)/2;
    const err = Math.abs(fm - lin);
    if((err < tol && depth>1) || depth>=maxDepth) {
      return [ {x:a,y:fa}, {x:mid,y:fm}, {x:b,y:fb} ];
    } else {
      // subdivide
      const left = adaptiveSample(fEval, a, mid, fa, fm, tol, depth+1, maxDepth);
      const right = adaptiveSample(fEval, mid, b, fm, fb, tol, depth+1, maxDepth);
      // merge, avoid duplicating mid
      const merged = [];
      if(left && left.length) merged.push(...left);
      if(right && right.length) merged.push(...right.slice(1));
      return merged;
    }
  }

  // build dataset from adaptive sampling over [-10,10]
  function buildDataset(fEval){
    const segments = [];
    const step = 1.0; // coarse segmentation across domain, refined adaptively inside
    for(let a=-10; a<10; a+=step){
      const b = a+step;
      const fa = fEval(a), fb = fEval(b);
      const seg = adaptiveSample(fEval, a, b, fa, fb, 0.6, 0, 12);
      if(seg && seg.length){
        // transform to arrays marking NaN for gaps
        for(let i=0;i<seg.length;i++) {
          segments.push(seg[i]);
        }
      } else {
        // create gap
        segments.push({x:a,y:NaN}, {x:b,y:NaN});
      }
    }
    // compress: produce arrays xs, ys, inserting nulls when y is NaN
    const xs = [], ys = [];
    for(const p of segments){
      xs.push(p.x);
      ys.push((isFinite(p.y) ? p.y : null));
    }
    return { xs, ys };
  }

  // compute range approx from finite y-values (and hide if decimals>2 or extreme)
  function computeRangeFrom(vals){
    const finite = vals.filter(v=>isFinite(v));
    if(finite.length===0) return null;
    const min = Math.min(...finite), max = Math.max(...finite);
    // hide if any requires >2 decimals in representation
    function needsManyDecimals(n){
      const s = Math.abs(Math.round(n*100)/100 - n);
      // if representation would change more than 0 -> require decimals; we only accept 2 decimals max
      const fixed = Math.round(n*100)/100;
      return !isFinite(n) || Math.abs(fixed - n) > 1e-6;
    }
    if(needsManyDecimals(min) || needsManyDecimals(max)) return null;
    // hide if range is extreme
    if(Math.abs(min) > 1e6 || Math.abs(max) > 1e6) return null;
    return { min: Math.round(min*100)/100, max: Math.round(max*100)/100 };
  }

  // Chart.js instance
  let chart = null;
  function plotChart(xs, ys, holes=[], vertAsym=[], obliqueLine=null){
    if(chart) chart.destroy();
    const ctx = $('chartCanvas').getContext('2d');

    // build dataset pairs for Chart.js (x numeric)
    const dataPoints = [];
    for(let i=0;i<xs.length;i++){
      const x = xs[i], y = ys[i];
      dataPoints.push({ x: Number((+x).toFixed(6)), y: (y===null ? null : Number(y)) });
    }

    // compute y min/max from finite y's and clamp
    const finiteYs = dataPoints.filter(p=>isFinite(p.y)).map(p=>p.y);
    let yMin = finiteYs.length ? Math.min(...finiteYs) : -10;
    let yMax = finiteYs.length ? Math.max(...finiteYs) : 10;
    if(finiteYs.length){
      if(!isFinite(yMin) || !isFinite(yMax)){ yMin=-10; yMax=10; }
      // clamp extremes for visual reasons
      const cap = 1000;
      if(yMax > cap) yMax = cap;
      if(yMin < -cap) yMin = -cap;
      // expand a bit
      const pad = Math.max(1, (yMax-yMin)*0.05);
      yMin -= pad; yMax += pad;
      if(yMax - yMin < 4){ const mid=(yMax+yMin)/2; yMin = mid-3; yMax = mid+3; }
    } else { yMin = -10; yMax = 10; }

    chart = new Chart(ctx, {
      type: 'line',
      data: { datasets: [{ label:'f(x)', data: dataPoints, parsing:false, spanGaps:false, borderWidth:2, pointRadius:0, tension:0.12 }] },
      options: {
        animation:false, responsive:true, maintainAspectRatio:false,
        scales:{
          x:{ type:'linear', min:-10, max:10, ticks:{ stepSize:2 } },
          y:{ type:'linear', min:yMin, max:yMax, ticks:{ stepSize: ((yMax-yMin)/5) } }
        },
        plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label: ctx => {
          const y = ctx.parsed.y;
          return (y===null ? 'indefinido' : 'f(' + ctx.parsed.x + ') = ' + (Math.abs(y-Math.round(y))<1e-8 ? Math.round(y) : (Math.round(y*100)/100)));
        } } } }
      }
    });

    // draw holes and vertical asymptotes and oblique line using overlay
    chart.options.plugins = chart.options.plugins || {};
    chart.update();
    const overlay = chart;
    const drawOverlay = () => {
      const chartArea = overlay.chartArea;
      const ctx2 = overlay.ctx;
      ctx2.save();
      // vertical asymptotes dashed
      ctx2.setLineDash([6,6]);
      ctx2.strokeStyle = '#9ca3af';
      ctx2.lineWidth = 1;
      for(const ax of vertAsym){
        if(ax < -10 || ax > 10) continue;
        const pixel = overlay.scales.x.getPixelForValue(ax);
        ctx2.beginPath(); ctx2.moveTo(pixel, chartArea.top); ctx2.lineTo(pixel, chartArea.bottom); ctx2.stroke();
      }
      ctx2.setLineDash([]);
      // holes (hollow circles)
      ctx2.fillStyle = '#fff'; ctx2.strokeStyle = '#111827'; ctx2.lineWidth = 2;
      for(const hx of holes){
        // find nearest plotted x to hx
        const nearest = dataPoints.reduce((best,p)=> Math.abs(p.x-hx) < Math.abs(best.x-hx) ? p : best, dataPoints[0]);
        if(!nearest || nearest.y===null || !isFinite(nearest.y)) continue;
        const xPix = overlay.scales.x.getPixelForValue(nearest.x);
        const yPix = overlay.scales.y.getPixelForValue(nearest.y);
        ctx2.beginPath(); ctx2.arc(xPix, yPix, 6, 0, 2*Math.PI); ctx2.fill(); ctx2.stroke();
      }
      // oblique line
      if(obliqueLine){
        ctx2.setLineDash([4,4]); ctx2.strokeStyle = '#ef4444'; ctx2.lineWidth = 1.2;
        const x1=-10, x2=10;
        const y1 = obliqueLine.m * x1 + obliqueLine.b;
        const y2 = obliqueLine.m * x2 + obliqueLine.b;
        const xPix1 = overlay.scales.x.getPixelForValue(x1);
        const xPix2 = overlay.scales.x.getPixelForValue(x2);
        const yPix1 = overlay.scales.y.getPixelForValue(y1);
        const yPix2 = overlay.scales.y.getPixelForValue(y2);
        ctx2.beginPath(); ctx2.moveTo(xPix1,yPix1); ctx2.lineTo(xPix2,yPix2); ctx2.stroke();
      }
      ctx2.restore();
    };
    // ensure overlay drawn after render
    chart.options.animation = chart.options.animation || {};
    chart.update();
    drawOverlay();
  }

  // compute polynomial roots by numeric scan is expensive; we attempt to find denom roots by sampling and then refine
  function findDenomRoots(denEval){
    const suspects = new Set();
    for(let x=-50; x<=50; x+=0.25){
      const v = denEval(x);
      if(!isFinite(v) || Math.abs(v) < 1e-6) suspects.add(Math.round(x*100)/100);
    }
    return Array.from(suspects).sort((a,b)=>a-b);
  }

  function computeRangeTextInterval(obj){
    if(!obj) return null;
    return `(${obj.min}, ${obj.max})`;
  }

  // main analyze
  function analyze(input){
    $('intro').style.display = 'none';
    $('details').style.display = 'none';
    $('rangeWrap') && ($('rangeWrap').style.display = 'none');

    const frac = splitFrac(input);
    if(!frac){ $('intro').textContent = 'Error: formato (numerador)/(denominador).'; return; }
    const [numStr, denStr] = frac;

    const numCompiled = compileExpr(numStr);
    const denCompiled = compileExpr(denStr);
    if(!numCompiled || !denCompiled){ $('intro').textContent = 'Error: no se pudo parsear la expresión.'; return; }

    function evalNum(x){ try{ return numCompiled.evaluate({x}); }catch{return NaN;} }
    function evalDen(x){ try{ return denCompiled.evaluate({x}); }catch{return NaN;} }
    function evalF(x){ const d=evalDen(x); const n=evalNum(x); if(!isFinite(d) || Math.abs(d) < 1e-12) return NaN; const val = n/d; return isFinite(val) ? val : NaN; }

    // denom zeros / singularities
    const denomRoots = findDenomRoots(evalDen);
    // classify holes vs vertical asymptotes
    const holes = [], verticals = [];
    for(const r of denomRoots){
      const nv = evalNum(r);
      if(isFinite(nv) && Math.abs(nv) < 1e-6) holes.push(r);
      else verticals.push(r);
    }

    // attempt simple simplification text (not symbolic factoring): if hole exists, note it
    let simplifiedText = 'No se simplifica';
    if(holes.length>0) simplifiedText = 'Cancelación en huecos posible';

    // asymptote estimate: check degrees via numeric growth
    // sample far values to detect horizontal or oblique
    let horizOblique = null;
    const vLarge1 = evalF(30000), vLarge2 = evalF(35000);
    if(isFinite(vLarge1) && isFinite(vLarge2) && Math.abs(vLarge1 - vLarge2) < 1){
      horizOblique = { type:'horizontal', value: r2((vLarge1+vLarge2)/2) };
    } else {
      // linear fit at large x
      const xsFit=[], ysFit=[];
      for(let X=20000; X<=30000; X+=2000){
        const y = evalF(X);
        if(isFinite(y)){ xsFit.push(X); ysFit.push(y); }
      }
      if(xsFit.length>=2){
        const n=xsFit.length;
        const sX=xsFit.reduce((a,b)=>a+b,0), sY=ysFit.reduce((a,b)=>a+b,0);
        const sXY=xsFit.map((v,i)=>v*ysFit[i]).reduce((a,b)=>a+b,0);
        const sX2=xsFit.map(v=>v*v).reduce((a,b)=>a+b,0);
        const m = (n*sXY - sX*sY) / (n*sX2 - sX*sX);
        const b = (sY - m*sX)/n;
        horizOblique = { type:'oblique', m: r2(m), b: r2(b) };
      }
    }

    // build adaptive dataset
    const ds = buildDataset(evalF);

    // compute approximate range and decide whether to show
    const rangeObj = (ds && ds.ys) ? (function(){
      const finiteYs = ds.ys.filter(v=>isFinite(v));
      return computeRangeFrom(finiteYs);
    })() : null;

    // fill UI
    $('simplified').textContent = simplifiedText;
    $('domainText').textContent = denomRoots.length ? ('Reales \\ { ' + denomRoots.map(r=>fmt(r)).join(', ') + ' }') : 'Reales';
    // domain math notation: build as union of intervals (approx)
    const domainMath = denomRoots.length ? (function(){
      const sorted = denomRoots.slice().sort((a,b)=>a-b);
      // create intervals between -inf and +inf excluding roots
      const parts=[];
      let left = -Infinity;
      for(const r of sorted){
        parts.push((left===-Infinity? '(-∞' : `(${fmt(left)}`) + `, ${fmt(r)})`);
        left = r;
      }
      parts.push(`(${fmt(sorted[sorted.length-1])}, ∞)`); // last to infinity
      // correct edge if only one root
      if(sorted.length===1) return `(-∞, ${fmt(sorted[0])}) ∪ (${fmt(sorted[0])}, ∞)`;
      return parts.join(' ∪ ');
    })() : '(-∞, ∞)';
    $('domainMath').textContent = domainMath;

    $('vertAsym').textContent = verticals.length ? verticals.map(v=> 'x=' + fmt(v)).join(', ') : 'Ninguna';
    $('horizAsym').textContent = horizOblique ? (horizOblique.type==='horizontal' ? 'y = ' + fmt(horizOblique.value) : ('y = ' + fmt(horizOblique.m) + 'x + ' + fmt(horizOblique.b))) : 'Ninguna';
    $('holes').textContent = holes.length ? holes.map(v=>'x='+fmt(v)).join(', ') : 'Ninguno';

    if(rangeObj){
      $('rangeWrap').style.display = 'block';
      $('rangeMath').textContent = `(${fmt(rangeObj.min)}, ${fmt(rangeObj.max)})`;
      $('rangeText').textContent = `Valores entre ${fmt(rangeObj.min)} y ${fmt(rangeObj.max)}`;
    } else {
      $('rangeWrap').style.display = 'none';
    }

    // table: show x values -4..4 and the holes/verticals (unique)
    const tableXs = [];
    for(let i=-4;i<=4;i++) tableXs.push(i);
    holes.forEach(h=> tableXs.push(Number(r2(h))));
    verticals.forEach(v=> tableXs.push(Number(r2(v))));
    const uniq = Array.from(new Set(tableXs)).sort((a,b)=>a-b);
    let html = '<table><tr>';
    uniq.forEach(x=> html += `<th>${fmt(x)}</th>`);
    html += '</tr><tr>';
    uniq.forEach(x=>{
      const y = evalF(x);
      html += `<td>${isFinite(y) ? fmt(y) : '<span class="danger">indefinido</span>'}</td>`;
    });
    html += '</tr></table>';
    $('tableWrap').innerHTML = html;

    $('details').style.display = 'block';
    // plot
    plotChart(ds.xs, ds.ys, holes, verticals, horizOblique && horizOblique.type==='oblique' ? {m:horizOblique.m,b:horizOblique.b} : null);
  }

  // helpers
  function buildDataset(fEval){
    const pts = [];
    // sample coarse and adaptively refine
    for(let a=-10; a<10; a+=1){
      const b = a+1;
      const fa = fEval(a), fb = fEval(b);
      const seg = adaptiveSample(fEval, a, b, fa, fb, 0.6, 0, 12);
      // seg is array of points possibly containing NaN entries; push them
      for(const p of seg) pts.push(p);
    }
    // compress consecutive duplicates
    const xs = [], ys = [];
    for(const p of pts){
      const x = Number(p.x);
      const y = (isFinite(p.y) ? p.y : null);
      xs.push(x); ys.push(y);
    }
    return { xs, ys };
  }

  // DOM shortcuts
  window.$ = $;
  $('btnAnalyze').addEventListener('click', ()=> analyze($('fnInput').value.trim()));
  $('fnInput').addEventListener('keydown', e=> { if(e.key==='Enter'){ e.preventDefault(); $('btnAnalyze').click(); } });

  // expose for debug
  window._analyze = analyze;
})();
</script>
</body>
</html>
